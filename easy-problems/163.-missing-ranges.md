---
description: https://leetcode.com/problems/missing-ranges/
---

# 163. Missing Ranges

> You are given an inclusive range `[lower, upper]` and a **sorted unique** integer array `nums`, where all elements are within the inclusive range.
>
> A number `x` is considered **missing** if `x` is in the range `[lower, upper]` and `x` is not in `nums`.
>
> Return _the **shortest sorted** list of ranges that exactly covers all the missing numbers_. That is, no element of `nums` is included in any of the ranges, and each missing number is covered by one of the ranges.
>
>
>
> **Example:**
>
> ```
> Input: nums = [0,1,3,50,75], lower = 0, upper = 99
> Output: [[2,2],[4,49],[51,74],[76,99]]
> Explanation: The ranges are:
> [2,2]
> [4,49]
> [51,74]
> [76,99]
> ```

#### Solution:

Another tough description. Let's break it down: we've got an array of integers and another pair of integers denoting a lower and upper bound. Any number between these two bounds is considered missing if it isn't also found in the nums array. We need to put together the smallest possible list of ranges (which are simply collections of an upper and lower bound) which includes every missing number, and _only_ missing numbers. \
\
Looking at the example gives us a simple idea:

* let's start by iterating from the beginning of the nums array until we reach the first value larger than the lower bound, which should be nums\[i] after the setup below:

```java
List<List<Integer> ranges = new ArrayList<>();
List<Integer> range = new ArrayList<>();

int i = 0;
while (i < nums.length && nums[i] < lower) i++;
```

* _edge case alert!_ If we've iterated through all the numbers without finding one larger than the provided lower bound, that must mean all the values from the lower to the upper bound exist outside of the nums array, making it rather simple to construct and return an answer:

```java
if (i == nums.length) {
    range.add(lower);
    range.add(upper);
    ranges.add(range);
    return ranges;
}
```

* having taken care of that, we can now assume we've found the first value larger than the provided lower bound, to which we ask: are you larger than the lower bound? if yes, we've found our first range! &#x20;

```java
if (nums[i] > lower) {
    range.add(lower);
    range.add(nums[i]-1);
    ranges.add(range);
}
```

* going forward, we can simply repeat this strategy for every pair of consecutive numbers:

```java
for (++i; i < nums.length && nums[i] <= upper; i++) {
    if (nums[i] - nums[i-1] > 1) {
        range = new ArrayList<>();
        range.add(nums[i-1]+1);
        range.add(nums[i]-1);
        ranges.add(range);
    }
}
```

* and top it off with the final range:

```java
public List<List<Integer>> findMissingRanges(int[] nums, int lower, int upper) {
    List<List<Integer>> ranges = new ArrayList<>();
    List<Integer> range = new ArrayList<>();

    int i = 0;
    while (i < nums.length && nums[i] < lower) i++;

    if (i == nums.length) {
        range.add(lower);
        range.add(upper);
        ranges.add(range);
        return ranges;
    }
    
    if (nums[i] > lower) {
        range.add(lower);
        range.add(nums[i]-1);
        ranges.add(range);
    }
    
    for (++i; i < nums.length && nums[i] <= upper; i++) {
        if (nums[i] - nums[i-1] > 1) {
            range = new ArrayList<>();
            range.add(nums[i-1]+1);
            range.add(nums[i]-1);
            ranges.add(range);
        }
    }
    
    if (upper > nums[nums.length-1]) {
        range = new ArrayList<>();
        range.add(nums[nums.length-1]+1);
        range.add(upper);
        ranges.add(range);
    }
    
    return ranges;
}
```
